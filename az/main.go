package main

import (
	"flag"
	"fmt"
	"github.com/ericaro/mrepo"
	"os"
)

// the main that run a command on all sub commands

var async = flag.Bool("a", false, "Controls the execution mode.\n           '-a' or '-a=true' run commands asynchronously.\n           '-a=false' of by default run commands sequentially.")
var list = flag.Bool("l", false, "Dry mode just list the repositories.")

// output selection
var cat = flag.Bool("cat", false, "concatenate outputs, and print it")
var sum = flag.Bool("sum", false, "parse each output as a number and print out the total")
var count = flag.Bool("count", false, "count different outputs, and prints the resulting histogram")
var digest = flag.Bool("digest", false, "compute the sha1 digest of all outputs")

// missing an outputer that takes care of "error codes"

var replay = flag.Bool("extract", false, "extract git info to rebuild the same structure.")

var help = flag.Bool("h", false, "Print this help.")

func main() {
	flag.Parse()
	if (flag.NArg() == 0 && !*replay) || *help {
		fmt.Printf(`USAGE %s [-options] <command> <args...>
			
DESCRIPTION:

  Run '<command> <args...>' is every repository found in the current directory hierarchy.

OPTIONS:
	
`, os.Args[0])
		flag.PrintDefaults()

		fmt.Println("\nEXAMPLE:\n")

		fmt.Printf("'%s git status -s'\n", os.Args[0])
		os.Exit(-1)
	}

	// use wd by default
	wd, err := os.Getwd()
	if err != nil {
		fmt.Printf("Error, cannot determine the current directory. %s\n", err.Error())
	}

	args := make([]string, 0)
	if flag.NArg() > 1 {
		args = flag.Args()[1:]
	}
	name := flag.Arg(0)

	scanner := mrepo.NewScan(wd)
	go func() {

		err = scanner.Find()
		if err != nil {
			fmt.Printf("Error scanning current directory (%s). %s", wd, err.Error())
		}
	}()

	//get the repository chan generated by Find call.
	repositories := scanner.Repositories()

	if *list {
		mrepo.List(repositories)
	} else if *replay {
		mrepo.Replay(repositories, wd)
	} else {

		// special outputs implies concurrent mode
		var special bool = true
		var outputer mrepo.PostProcessor = mrepo.Default
		switch {
		case *cat:
			outputer = mrepo.Cat
		case *sum:
			outputer = mrepo.Sum
		case *count:
			outputer = mrepo.Count
		case *digest:
			outputer = mrepo.Digest
		default:
			outputer, special = mrepo.Default, false
		}

		if special || *async { // this implies concurrent
			// based on the async option, exec asynchronously or sequentially.
			// we cannot just make "seq" a special case of concurrent, since when running sequentially we provide
			// direct access to the std streams. commands can use stdin, and use term escape codes.
			// When in async mode, we just can't do that.
			mrepo.Concurrent(repositories, !special, outputer, name, args...)
		} else {
			mrepo.Seq(repositories, name, args...)
		}
	}

}
