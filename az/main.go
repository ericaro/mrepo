package main

import (
	"flag"
	"fmt"
	"github.com/ericaro/mrepo"
	"os"
)

// the main that run a command on all sub commands

var async = flag.Bool("a", false, "Controls the execution mode.\n           '-a' or '-a=true' run commands asynchronously.\n           '-a=false' of by default run commands sequentially.")
var list = flag.Bool("l", false, "Dry mode just list the repositories.")

// output selection
var cat = flag.Bool("cat", false, "concatenate outputs, and print it")
var sum = flag.Bool("sum", false, "parse each output as a number and print out the total")
var count = flag.Bool("count", false, "count different outputs, and prints the resulting histogram")
var digest = flag.Bool("digest", false, "compute the sha1 digest of all outputs")

// missing an outputer that takes care of "error codes"

var help = flag.Bool("h", false, "Print this help.")

func main() {
	flag.Parse()
	if (flag.NArg() == 0 && !*list) || *help {
		fmt.Printf(`USAGE %s [-options] <command> <args...>
			
DESCRIPTION:

  Run '<command> <args...>' is every repository found in the current directory hierarchy.

OPTIONS:
	
`, os.Args[0])
		flag.PrintDefaults()

		fmt.Println("\nEXAMPLE:\n")

		fmt.Printf("'%s git status -s'\n", os.Args[0])
		os.Exit(-1)
	}

	// use wd by default
	wd, err := os.Getwd()
	if err != nil {
		fmt.Printf("Error, cannot determine the current directory. %s\n", err.Error())
	}
	executor := mrepo.NewExecutor(wd)
	// parses the remaining args in order to pass them to the underlying process
	args := make([]string, 0)
	if flag.NArg() > 1 {
		args = flag.Args()[1:]
	}
	name := flag.Arg(0)

	scanner := mrepo.NewScan(wd)
	go func() {
		err = scanner.Find()
		if err != nil {
			fmt.Printf("Error scanning current directory (%s). %s", wd, err.Error())
		}
	}()

	//get the repository chan generated by Find call.
	repositories := scanner.Repositories()

	if *list {
		//for now there is only one way to print dependencies
		executor.List(repositories)
	} else {
		// select the output mode

		//again, passing the stdin, and stdout to the subprocess prevent: async, and ability to collect the outputs
		// for special outputers we need to collect outputs, so the 'special' var.
		// special => concurrent mode (because we need to collect outputs)
		// Therefore, selecting the output mode imply selecting "special"= true|false
		// and the PostProcessor function
		var special bool = true

		switch {
		case *cat:
			executor.PostProcessor = mrepo.Cat
		case *sum:
			executor.PostProcessor = mrepo.Sum
		case *count:
			executor.PostProcessor = mrepo.Count
		case *digest:
			executor.PostProcessor = mrepo.Digest
		default:
			special = false
		}

		if special || *async { // this implies concurrent
			// based on the async option, exec asynchronously or sequentially.
			// we cannot just make "seq" a special case of concurrent, since when running sequentially we provide
			// direct access to the std streams. commands can use stdin, and use term escape codes.
			// When in async mode, we just can't do that.
			executor.Concurrent(repositories, name, args...)
		} else {
			executor.Seq(repositories, name, args...)
		}
	}

}
